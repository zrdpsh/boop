
<!DOCTYPE html>
<html>
<body>


<h1>DocSearch</h1>
<p>
Приложение индексирует содержимое всех книжных файлов на телефоне, после чего можно быстро искать ключевые слова или фразы во всей библиотеке.
</p>
<p>
Допустим, вся визуальная часть приложения наследуется от родительского класса-прямоугольника, 
у которого должны быть поля для 
<ul>
  <li>координат одного из углов самого прямоугольника</li>
  <li>длин сторон</li>
  <li>отступов от одного из краев экрана</li>
</ul>
</p>
<p>
Уже от него можно наследовать классы:
<ul>
  <li>Общий_экран</li>
  <li>Поле_для_ввода</li>
  <li>Выпадающее_меню</li>
  <li>Кнопка</li>
  <li>Пункт_Меню</li>
</ul>
</p>
<p>
От каждого из перечисленных можно строить дерево дальше, добавляя:
<ul>
  <li>цвет</li>
  <li>текст внутри прямоугольника</li>
  <li>возможность реагировать на нажатия - и, соответственно, поля типа pressed - hover - unavailable </li>
  <li>порядковый номер для элементов списка</li>
</ul>
</p>
<p>

<p>
Работа с приложением подразумевает, что должен быть класс "Найденная_книга", содержащий как минимум:
<ul>
  <li>название файла</li>
  <li>дату последнего изменения</li>
  <li>количество вхождений искомого слова</li>
  <li>пропорцию ключевых слов по отношению друг к другу, если слов несколько</li>
  <li>собственно, список строк с вхождениями (для Full text view)</li>
  <li>ссылку на файл документа </li>
</ul>

Можно предположить, что значениями полей из этого объекта заполняются поля в объекте Элемент_списка_выдачи, который наследуется от перечисленных выше
</p>

<h1>Chess</h1>
<p>
Для Шахмат логично создать класс-родитель с единственными параметрами, общими для всех фигур:<br><br>
класс шахматная_фигура {
<ul>
	<li>съедена: да/нет
	<li>позиция на доске: E7
}</ul>

от него образовать конкретные фигуры, присваивая имя, цвет и список возможных и невозможных ходов. Список обновляется после каждого хода. <br><br>
класс ладья {
<ul>
	<li>название: ладья;<br>
	<li>цвет: белый;<br>
	<li>позиция на доске: A1;<br>
	<li>съедена: нет;<br>
	<li>можно ходить [];<br>
	<li>нельзя ходить [B2, C2, ... , G8, H8];<br>
}</ul>
"Внутрь" фигуры можно записывать последовательность её ходов - или создать для этого отдельный класс Партия.<br>
Отдельно создаются классы для отрисовки игры на экране. Ходам фигуры надо сопоставить пиксели.<br>
Также должен быть класс Игрок - играющий чёрными или белыми.<br>


Можно предположить, что значениями полей из этого объекта заполняются поля в объекте Элемент_списка_выдачи, который наследуется от перечисленных выше
</p>


<h1>Blender</h1>
<p>
В 3D-редакторах использование объектного подхода зашито в принцип работы таких программ -
 сцена состоит из неких сущностей, описываемых набором числовых и логических параметров (поля), которые можно произвольно менять (методы).
 
 По аналогии с DocSearch, трехмерные примитивы должны наследоваться от объекта типа гизмо, у которого есть только координаты xyz.
</p>

</body>
</html>
