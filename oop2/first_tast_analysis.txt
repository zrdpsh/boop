Методы я добавил сразу, ещё в первом задании.

---------------------------------------------------------------------
Классы и логику подгонял под действия в примере
- дворфы сражаются за альпак, поэтому нужен класс Alpaca с единственным параметром - пострижена или нет. 
Количество шерсти от каждой стрижки решил сделать одинаковым, поэтому у альпак этого параметра нет, 
а само это количество прописано в классе Dwarf, в методе стрижки. Можно вернуть этот параметр альпаке(например, потому,
что альпаки бывают более или менее волосатые, или вообще потому, что все они разные), прописывать это количество шерсти при создании объекта класса, 
а при стрижке обращаться к нему изнутри Dwarf.shearAplaca()

- у молота основной параметр урон, плюс я добавил второй параметр resource, который уменьшается при каждой атаке, т.е. оружие не вечно и изнашивается.

- Дворф должен уметь атаковать/получать урон и накапливать/терять шерсть после стрижки альпака или поражения от другого игрока. 
Получилось три базовых параметра - имя, количество "здоровья" и количество мотков шерсти, и соответствующие им методы: presentYourself() для имени,
isDead(), showHealth() и attack() для здоровья, increaseWool() и returnWool(), чтобы собирать и обнулять количество собранной шерсти.



---------------------------------------------------------------------
В отличие от эталонного решения здесь нет параметров Dwarf.drink, Animal.speed и Weapon.range.

Имена и профессии решил прописывать строкой, а не использовать числовые коды.

Параметры description, profession, canShearAlpacas, canAttackWithHammer у дворфа 
и метод attack() у альпак в примере не понадобились.


Не сразу вспомнил, что к свойствам класса можно обращаться напрямую, через точку, поэтому сразу писал геттеры и сеттеры для каждого свойства,
и поэтому класс Дворф получился такой большой.

Вообще, получается, что каждому числовому свойству логично сопоставлять как минимум три метода - увеличить, уменьшить и напечатать/вернуть значение.