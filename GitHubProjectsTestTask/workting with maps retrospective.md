Главный трюк в первом задании - это то, что словарь перезапишет ключ, если такой внутри уже есть. 
То есть после того, как программа благополучно запустилась в первый раз, 
заметил в логере, что после создания словаря в нём не 100 значений, а 65 (и это был бы хороший кандидат в assertion, кстати).
До сих пор есть привычка не трогать уже написанный код без веского повода, поэтому вместо if key.contains i-- continue, как в образце, просто добавил ещё один цикл, который добивает словарь до нужной длины после того, как отработал первый. Плохо. Добавил трекер проекта, который сейчас осваивать начал.
Аналогично можно исправить работу печатающего цикла с Map.remove() внутри тела цикла вместо Map.clear() по его окончании - так получается читабельней.

Во втором задании ещё больше претензий к избыточности написанного.
Точно не нужна громоздкая проверка с null на наличие значения в словаре c тернарным оператором - не дочитал про containsKey(). Нравятся однострочные решения, 
но вариант с contains ясный.
Плюс здесь тоже лишний цикл, т.к. заполнять результирующий словарь значениями и фильтровать ненужные вполне логично и за один проход. 
Я же сначала положил внутрь всё, а после удалял ненужное. Поскольку словари копируются по ссылке, кроме лишнего цикла появляется ещё и ненужный второй словарь для отфильтрованных значений, копия первого.

По итогу - сплошной мусорный код. Лучше завести привычку через некоторое время после работы вдуматься в то, что именно тебе надо было сделать - и после этого взглянуть на готовый код ещё раз.
